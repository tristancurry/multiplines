<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplines</title>
    <style>
        input {
            display: block;
            width: 100%;
        }

        datalist {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            writing-mode: vertical-lr;
            width: 100%;
        }

        svg {
            /* width: 100%; */
        }

        #numberlines {
            position: relative;
            width: 75%;
        }

        #layered {
            display: flex;
            position: relative;
            justify-content: center;
            height: 100%;
            width: fit-content;
            overflow:hidden;    
        }

        .range_overlay {
            position: absolute;
            display: block;

            -webkit-appearance: none; /* Hides the slider so that custom slider can be made */
            background: transparent; /* Otherwise white in Chrome */

            width: auto;
            padding: 0px;
            margin: 0px;
            box-sizing: border-box;
            height: 0px;
            top: 35%;
            width: 101%;
        }

        .range_overlay::-webkit-slider-thumb {
            -webkit-appearance:none;
            /* border: 1px solid #000000; */
            height: 100px;
            width: 1%;
            background: #09b668;
            cursor: pointer;
            margin-top: 0px;
        }

        .range_overlay::-moz-range-thumb {
            height: 100px;
            width: 1%;
            background: #09b668;
            cursor: pointer;
            margin-top: 0px;
            border-radius: 0px;
            border:none;
        }

        .range_overlay::-ms-thumb {
            height: 100px;
            width: 1%;
            background: #09b668;
            cursor: pointer;
            margin-top: 0px;
        }

        .range_overlay:focus {
            outline:none;
        }

        .range_overlay::-ms-track {
            width: 100%;
            cursor: pointer;

            /* Hides the slider so custom styles can be added */
            background: transparent; 
            border-color: transparent;
            color: transparent;
        }

        .ticknumber {
            font-size: 0.5em;
            justify-content: center;
            fill: black;
            stroke: none;
        }

        #nl_dynamic {
            top: 65%;
        }

        #svg_axes {
            stroke-width: 0.75px;
        }

    </style>
</head>
<body>
    <div id="numberlines">


        <div id="layered">

            <input type="range" class="range_overlay" id="nl_static" step="any" max="100">
            <input type="range" class="range_overlay" id="nl_dynamic"  step="any" max="100">
            <svg width="500" height="500" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                <defs>
                 <path id="tickmark" d="m0 -5v10" fill="none" stroke="#000" stroke-linecap="square"/>
                 <path id="indicator" d="m0 -20v10" fill="none" stroke="#ff0000" stroke-linecap="square"/>

                </defs>
                <g fill="none" id="svg_axes" stroke="#000">
                    <g id="svg_static">
                        <path id="axis_static" d="m-25 35h150"/>
                        <g class="tickmarks"></g>
                    </g>
                    <g id="svg_dynamic">
                        <path id="axis_dynamic" d="m-25 65h150"/>
                        <g class="tickmarks"></g>
                    </g>
                </g>
                
               </svg>
        </div>
        <input type="range" id="sf" min="0.1" max="10" step="0.1" />
    </div>


    <script>
        let factor = 2;
        let divide = false; 

        const xmlns = 'http://www.w3.org/2000/svg';
        const xlink = 'http://www.w3.org/1999/xlink';

        //give the sliders and their containing element a reference in code.
        //Variable names are the same as element id just for consistency,
        //it doesn't cause awkward collisions anywhere.
        const numberlines = document.getElementById('numberlines');
        const svg_box = document.getElementsByTagName('svg')[0];

        const svg_static = document.getElementById('svg_static');
        const ticks_static = svg_static.getElementsByClassName('tickmarks')[0];
        const nl_static = document.getElementById('nl_static');

        const svg_dynamic = document.getElementById('svg_dynamic');
        const ticks_dynamic = svg_dynamic.getElementsByClassName('tickmarks')[0];
        const nl_dynamic = document.getElementById('nl_dynamic');

        const indicator = document.createElementNS(xmlns, 'use');

        indicator.setAttributeNS(xlink, 'xlink:href', '#indicator');
        svg_box.appendChild(indicator);

        const params_static = {min:-1, max:11, x:10, y:35, spacing:10};
        const params_dynamic = {min:-1, max:11, x:10, y:65, spacing:10};

        //set event listeners on the two sliders
        //if there were more sliders to synchronise, a loop over the input elements
        //in the containing div would be a good way to set these up.
        //NB: there's a difference between input.value, and the input's HTML 'value' attribute
        nl_static.addEventListener('input', event => {
            nl_dynamic.value = nl_static.value;
            indicator.setAttribute('transform', `translate(${nl_dynamic.value}, 65)`);
        });

        nl_dynamic.addEventListener('input', event => {
            nl_static.value = nl_dynamic.value;
            indicator.setAttribute('transform', `translate(${nl_dynamic.value}, 65)`);

        });

        const sf = document.getElementById('sf');
        sf.addEventListener('input', event => {
            factor = parseFloat(sf.value);
            updateScaleFactor(factor);
        });
        updateParams(params_dynamic);
        updateScaleFactor(factor);
        generateTickmarks(ticks_static, params_static);
        nl_static.value = 0;
        nl_static.dispatchEvent(new Event('input'));

        //this function does all the various things that need to happen whenever the scale factor is adjusted.
        function updateScaleFactor(n) {
            factor = n;

            let currentMappedValue = map_value(nl_dynamic.value, 0, 100, params_dynamic.min, params_dynamic.max);
            params_dynamic.spacing = factor*params_static.spacing;
            generateTickmarks(ticks_dynamic, params_dynamic);

            updateParams(params_dynamic);

            nl_dynamic.value = map_value(currentMappedValue, params_dynamic.min, params_dynamic.max, 0, 100);

            if(!divide) {
                nl_dynamic.dispatchEvent(new Event('input'));
            } else {
                nl_static.dispatchEvent(new Event('input'));
            }
        }

        //this is used to produce the SVG axis with appropriate spacings and numbering of tick marks
        function generateTickmarks (target, params) {

            //remove existing tickmarks and numbers
            while (target.firstChild) {
                target.firstChild.remove();
            }

            let inc = 1;
            let spacing = params.spacing;

            //if spacing is too big, inject intermediate tick marks...

            while (spacing > 50) {
                spacing = spacing/2;
                inc = inc/2;
            }

            // while (spacing < 9) {
            //     spacing = spacing*2;
            //     inc = inc*2;
            // }

            let firstTick = inc*Math.ceil(params.min/inc);
            let firstTickPos = map_value(firstTick, params.min, params.max, 0, 100);
            let n_ticks = Math.floor((100 - firstTickPos)/spacing);
            console.log(firstTick);
            //if the origin position is positive, we will need extra tick marks to cover the negative numbers visible on axis.
            //if the origin position is negative, we can reduce the number of tick marks drawn.

            for (let i = 0; i <= n_ticks; i++) {
                let tick = document.createElementNS(xmlns, 'use');
                tick.setAttribute('transform', `translate(${firstTickPos + i*spacing}, ${params.y})`);
                tick.setAttributeNS(xlink, 'xlink:href', '#tickmark');
                target.appendChild(tick);
                let num = document.createElementNS(xmlns, 'text');
                num.setAttribute('class', 'ticknumber');
                num.setAttribute('transform', `translate(${firstTickPos + i*spacing}, ${params.y + 13})`);
                num.insertAdjacentText('beforeend', `${firstTick + i*inc}`);
                target.appendChild(num);
            }
        }

        
        //find current min and max on a scale...
        function axisMinMax(originX, spacing) {
            let spacings = 100/spacing;
            let min = (0 - originX)/spacing;
            let max = (100 - originX)/spacing;
            return ({min, max});
        }

        //dispense new min and max to params object
        function updateParams(params) {
            let minmax = axisMinMax(params.x, params.spacing);
            params.min = minmax.min;
            params.max = minmax.max;
        }

        //map a value on one range to its corresponding value on a new range
        function map_value(value, min_old, max_old, min_new, max_new) {
            let p = (value - min_old)/(max_old - min_old);
            return (p*(max_new - min_new) + min_new);
        }
    </script>
</body>
</html>